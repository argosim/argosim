package at.ac.univie.knasmueller.hulk;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import at.cibiv.ngs.tools.bed.BedWriter;
import at.cibiv.ngs.tools.bed.SimpleBEDFile;
import at.cibiv.ngs.tools.lds.GenomicInterval;
import at.cibiv.ngs.tools.util.FileUtils;

public class BedInformation {

	/**
	 * @author bernhard.knasmueller@univie.ac.at
	 * 
	 */

	private File bedFile;
	private SimpleBEDFile simpleBEDFile;
	private File tmpDir;

	public BedInformation(File bedFile, File tmpDir) throws IOException {
		this.tmpDir = tmpDir;
		this.simpleBEDFile = new SimpleBEDFile(bedFile);
	}

	public File writeBedFile() {

		return new File(""); // TODO changeme
	}

	public void addPositionModifier(String chr, int position, int offset)
			throws IOException {

		File correctedBed = createTempFile();
		correctedBed.createNewFile();

		BedWriter bw = new BedWriter(new PrintStream(new FileOutputStream(
				correctedBed)));

		for (GenomicInterval gi : this.simpleBEDFile.getIntervalsList()) {
			gi.setAnnotation(null, null);
			if (gi.getChr().equals(chr)) {
				if (offset > 0) {
					if (gi.getLeftPosition().get0Position() > position) {
						// whole interval gets modified
						GenomicInterval modifiedGi = new GenomicInterval(
								gi.getChr(), gi.getMin() + offset, gi.getMax()
										+ offset, gi.getUri());
						modifiedGi.setAnnotation(null, null);
						bw.add(modifiedGi);
					} else if (gi.getLeftPosition().get0Position() < position
							&& gi.getRightPosition().get0Position() >= position) {
						// insertion is IN the interval - only change right
						// boundary
						GenomicInterval modifiedGi = new GenomicInterval(
								gi.getChr(), gi.getMin(), gi.getMax() + offset,
								gi.getUri());
						modifiedGi.setAnnotation(null, null);
						bw.add(modifiedGi);
					} else {
						bw.add(gi);
					}
				} else if (offset < 0) {
					if (gi.getLeftPosition().get0Position() >= position ) {
						if (gi.getRightPosition().get0Position() < position
								+ Math.abs(offset)) {
							continue;
							// interval gets deleted
						} else {
							long newMin = gi.getMin() - Math.abs(offset);
							if(newMin < 0)
								newMin = 0;
							GenomicInterval modifiedGi = new GenomicInterval(
									gi.getChr(),
									newMin, gi.getMax()
											- Math.abs(offset), gi.getUri());
							modifiedGi.setAnnotation(null, null);
							bw.add(modifiedGi);
						}
					} else if (gi.getLeftPosition().get0Position() < position) {
						if (gi.getRightPosition().get0Position() >= position) {
							if(gi.getRightPosition().get0Position() < position + Math.abs(offset)) {
								GenomicInterval modifiedGi = new GenomicInterval(
										gi.getChr(), gi.getMin(),
										(long) position - 1, gi.getUri());
								modifiedGi.setAnnotation(null, null);
								bw.add(modifiedGi);
							} else {
								GenomicInterval modifiedGi = new GenomicInterval(
										gi.getChr(), gi.getMin(),
										gi.getMax() - Math.abs(offset), gi.getUri());
								modifiedGi.setAnnotation(null, null);
								bw.add(modifiedGi);
							}
						} else {
							bw.add(gi);
						}
					}
				}
			}

		}
		bw.close();
		System.out.println(correctedBed);

	}

	private File createTempFile() {
		String prefix = "tmp";
		return FileUtils.createTempFile(tmpDir, prefix);
	}

	public File getBedFile() {
		return bedFile;
	}

	public void setBedFile(File bedFile) {
		this.bedFile = bedFile;
	}

	public static void main(String[] args) {
		try {
			BedInformation bedInformation = new BedInformation(new File(
					"/project/bakk/bed/example_taurus.bed"), new File(
					"/project/bakk/tmp/"));
			bedInformation.addPositionModifier("chr1", 0, -50);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

}
